#!/bin/bash
imagesPath=${image_path:-"/tmp/images"}
keysPath=${key_path:-"/tmp/keys"}
currentPath=$(pwd)

#images=$(ls $imagesPath | grep .deb)
#FILES="sw-description sw-description.sig $images"

usageString="
Usage: swupdate-generate [OPTIONS]

Options:
  -a, --imagesPath       :set your deb package path
  -b, --keysPath         :set your key path
  -c, --cpio             :generate a swu file through sw-description 
                          sw-description.sig and our deb packages
  -e, --encrypt          :symmetrically encrypted update images
  -h, --help             :print this help message and exit
  -k, --rsa              :generate a private key and a public key with RSA
  -K, --cms              :generate a private key and a public key with CMS
  -s, --sign             :sign sw-description with CMS
"

ARGS=`getopt -o a:b:hkKesc -l image_path:,key_path:,help,rsa,cms,encrypt,sign,cpio -n 'please correct your parameter' -- "$@"`

if [ $? != 0 ]; then
    echo "$usageString"
    exit 1
fi

eval set -- "${ARGS}"

while [ -n "$1" ];
do
  case "$1" in
    -h|--help ) echo "$usageString"
      exit 1
      ;;
    -s|--sign ) signature=true
      shift
      ;;
    -k|--rsa ) #rsaKey=true
      echo "generate rsa key"
      cd $keysPath
      check_cms_key=$(ls | grep "mycert.*")
      if [ -n "$check_cms_key" ]; then
        rm mycert.key.pem mycert.cert.pem
      fi
      echo "generate rsa key in $keysPath"
      openssl genrsa -aes256 -out priv.pem
      openssl rsa -in priv.pem -out public.pem -outform PEM -pubout
      shift
      ;;
    -K|--cms ) #cmsKey=true
      echo "generate cms key"
      cd $keysPath
      check_rsa_key=$(ls | grep -E "priv.pem|public.pem")
      if [ -n "$check_rsa_key" ]; then
        rm priv.pem public.pem
      fi
      echo "generate cms key in $keysPath"
      openssl req -x509 -newkey rsa:4096 -nodes -keyout mycert.key.pem \
      -out mycert.cert.pem -subj "/O=SWUpdate /CN=target"
      shift
      ;;
    -c|--cpio ) cpio=true
      shift
      ;;
    -e|--encrypt ) encrypt=true
      shift
      ;;
    -a|--image_path )
      imagesPath=$2
      echo $imagesPath
      shift
      ;;
    -b|--key_path )
      keysPath=$2
      echo $keysPath
      shift
      ;;
    -- ) 
      shift
      break
      ;;
    * ) echo "Wrong Option";
      exit 1
      ;; 
  esac
  shift
done

# Make sure that $1 references the first "real" option.
shift $(($OPTIND - 1))

if [ "$imagespath" = true ]; then
  
  imagesPath=$2
  echo $imagesPath
fi

if [ "$keyspath" = true ]; then
  keysPath=$2
  echo $keysPath
fi

if [ "$signature" = true ]; then
  cd $currentPath
  image_num=$(ls -l | grep ".enc" | wc -l)
  if [ $image_num -eq 0 ]; then
    #If there is no encrypted image, copy all file to currentPath
    images=$(ls $imagesPath | grep .deb)
    cp_imagesPath="$imagesPath/*"
    cp $cp_imagesPath $currentPath
    #Count the number of images  
    cd $imagesPath
    image_num=$(ls -l |grep ".deb" | wc -l)
    cd $currentPath
    for ((c=1;c<=$image_num;c++))
    do
      #Rewrite sw-description
      if [ $c -eq 1 ] ; then
        sed '/images: (/a\\t\t{\n\t\t\t'"imagename_$c"'\n\t\t\t'"imagesha256_$c"'\n\t\t\t'"type_$c"'\n\t\t}\n' sw-description.template > sw-description
      else
        sed -i '/images: (/a\\t\t{\n\t\t\t'"imagename_$c"'\n\t\t\t'"imagesha256_$c"'\n\t\t\t'"type_$c"'\n\t\t},\n' sw-description
      fi
    done
  else
    #If there are encrypted images
    rm -f encryptIvt
    images=$(ls $currentPath | grep .enc)
    #Copied these encrypted images to current path
    image_num=$(ls -l |grep ".enc" | wc -l)
    for ((c=1;c<=$image_num;c++))
    do
      #Rewrite sw-description
      encryptIvt=$(cat Ivt_$c)
      if [ $c -eq 1 ] ; then
        sed '/images: (/a\\t\t{\n\t\t\t'"imagename_$c"'\n\t\t\t'"imagesha256_$c"'\n\t\t\t'"type_$c"'\n\t\t\t'"encrypted = true;"'\n\t\t\t'"ivt = \"$encryptIvt\""\;'\n\t\t}\n' sw-description.template > sw-description
      else
        sed -i '/images: (/a\\t\t{\n\t\t\t'"imagename_$c"'\n\t\t\t'"imagesha256_$c"'\n\t\t\t'"type_$c"'\n\t\t\t'"encrypted = true;"'\n\t\t\t'"ivt = \"$encryptIvt\""\;'\n\t\t},\n' sw-description
      fi  
    done 
  fi
  b=1
  for image in $images
  do
    sha256_sum=$(sha256sum $image)
    sha256_num="${sha256_sum:0:64}"
    imagename="imagename_$b"
    filename='filename = '\"$image\"';'
    typename="type_$b"
    sha256name="imagesha256_$b"
    sha256="sha256 = \"$sha256_num\";"
    sed -i "s/$imagename/$filename/g" sw-description
    sed -i "s/$sha256name/$sha256/g" sw-description
    result=$(echo $image | grep ".deb")
    if [ -n "$result" ] ; then 
      type="type = \"deb-lua\";"
      sed -i "s/$typename/$type/g" sw-description
    else
      type="type = \"deb-purge\";"
      sed -i "s/$typename/$type/g" sw-description
    fi
    let b=$b+1
  done
  check_sign_way=$(ls $keysPath | grep mycert)
  if [ "$check_sign_way" = "" ]; then
    #RSA sign
    echo "sign sw-description with rsa"
    privateKey="$keysPath/priv.pem"
    openssl dgst -sha256 -sign $privateKey sw-description > sw-description.sig
  else
    #CMS sign
    echo "sign sw-description with cms"
    privateKey="$keysPath/mycert.key.pem"
    publicKey="$keysPath/mycert.cert.pem"
    openssl cms -sign -in  sw-description -out sw-description.sig -signer $publicKey \
    -inkey $privateKey -outform DER -nosmimecap -binary
  fi
fi

if [ "$rsaKey" = true ]; then
  cd $keysPath
  check_cms_key=$(ls | grep "mycert.*")
  if [ -n "$check_cms_key" ]; then
    rm mycert.key.pem mycert.cert.pem
  fi
  echo "generate rsa key in $keysPath"
  openssl genrsa -aes256 -out priv.pem
  openssl rsa -in priv.pem -out public.pem -outform PEM -pubout
fi

if [ "$cmsKey" = true ]; then
  cd $keysPath
  check_rsa_key=$(ls | grep -E "priv.pem|public.pem")
  if [ -n "$check_rsa_key" ]; then
    rm priv.pem public.pem
  fi
  echo "generate cms key in $keysPath"
  openssl req -x509 -newkey rsa:4096 -nodes -keyout mycert.key.pem \
  -out mycert.cert.pem -subj "/O=SWUpdate /CN=target"
fi

if [ "$cpio" = true ]; then
  #generate a swu file
  cd $currentPath
  image_num=$(ls -l |grep ".enc" | wc -l)
  if [ $image_num -eq 0 ]; then
    images=$(ls $imagesPath | grep .deb)
    FILES="sw-description sw-description.sig $images"
  else
    rm Ivt_*
    images=$(ls $currentPath | grep .enc)
    FILES="sw-description sw-description.sig $images"
  fi
  read -p "please input your swu file name : " input
  for filename in $FILES
  do
    echo $filename
  done | cpio -ov -H crc > $input
  for filename in $FILES
  do
    rm $filename
  done
fi

if [ "$encrypt" = true ]; then
  echo "This is encrypt process"
  images=$(ls $imagesPath | grep .deb)
  cd $imagesPath 
  a=1
  encryptKey=$(openssl rand -hex 32)
  for image in $images
  do
    encryptIvt=$(openssl rand -hex 16)
    echo $encryptIvt > Ivt_$a
    openssl enc -aes-256-cbc -in $image -out $image.enc -K $encryptKey -iv $encryptIvt
    #Move these encrypted images to current path
    mv $image.enc $currentPath
    mv Ivt_$a $currentPath
    let a=$a+1
  done
fi